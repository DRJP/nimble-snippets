% Generated by roxygen2: do not edit by hand
% Please edit documentation in R/APT_build.R
\name{buildAPT}
\alias{buildAPT}
\title{Create an APT function, from an MCMCconf object}
\usage{
buildAPT(conf, Temps, monitorTmax = TRUE, ULT = 1e+06, thinPrintTemps = 1,
  ...)
}
\arguments{
\item{conf}{An object of class MCMCconf that specifies the model, samplers,
monitors, and thinning intervals for the resulting MCMC function.  See
\code{configureMCMC} for details of creating MCMCconf objects.
Alternatively, \code{MCMCconf} may a NIMBLE model object, in which case an
MCMC function corresponding to the default MCMC configuration for this
model is returned.}

\item{...}{Additional arguments to be passed to \code{configureMCMC} if
\code{conf} is a NIMBLE model object}
}
\description{
Addapted from buildMCMC. Accepts a single required argument, which
may be of class MCMCconf, or inherit from class modelBaseClass (a
NIMBLE model object).  Returns an APT function; see details
section.
}
\details{
Calling buildAPT(conf,Temps,monitorTmax,ULT,thinPrintTemps) will
produce an uncompiled (R) APT function object, say 'myAPT'.

The uncompiled MCMC function will have arguments:

\code{niter}: The number of iterations to run the MCMC.

\code{reset}: Boolean specifying whether to reset the internal MCMC
sampling algorithms to their initial state (in terms of self-adapting
tuning parameters), and begin recording posterior sample chains anew.
Specifying \code{reset=FALSE} allows the MCMC algorithm to continue running
from where it left off, appending additional posterior samples to the
already existing sample chains. Generally, \code{reset=FALSE} should only
be used when the MCMC has already been run (default = TRUE).

\code{resetTempering}: Boolean specifying whether to reset the
flexibility of the temperature ladder's adaptation process.

\code{simulateAll}: Boolean specifying whether to simulate into all
stochastic nodes.  This will overwrite the current values in all stochastic
nodes (default = FALSE).

\code{time}: Boolean specifying whether to record runtimes of the
individual internal MCMC samplers.  When \code{time=TRUE}, a vector of
runtimes (measured in seconds) can be extracted from the MCMC using the
method \code{mcmc$getTimes()} (default = FALSE).

\code{adaptTemps}: Boolean specifying whether the temperature
ladder will be adaptated or not.

\code{printTemps}: Boolean specifying whether the temperature
ladder will be printed during the MCMC. THe print frequency is
controled by thinPrintTemps.

\code{tuneTemper1}: Numeric tuning parameter of the adaptation
process of the temperature ladder. See source code for
buildAPT. Defaults to 10.

\code{tuneTemper2}: Numeric tuning parameter of the adaptation
process of the temperature ladder. See source code for
buildAPT. Defaults to 1.

\code{progressBar}: Boolean specifying whether to display a progress bar
during MCMC execution (default = TRUE).  The progress bar can be
permanently disabled by setting the system option
\code{nimbleOptions(MCMCprogressBar = FALSE)}.

Samples corresponding to the \code{monitors} and \code{monitors2} from the
MCMCconf are stored into the interval variables \code{mvSamples} and
\code{mvSamples2}, respectively. These may be accessed and converted into R
matrix objects via: \code{as.matrix(mcmc$mvSamples)}
\code{as.matrix(mcmc$mvSamples2)}

The uncompiled (R) MCMC function may be compiled to a compiled MCMC object,
taking care to compile in the same project as the R model object, using:
\code{Cmcmc <- compileNimble(Rmcmc, project=Rmodel)}

The compiled function will function identically to the uncompiled object,
except acting on the compiled model object.
}
\section{Calculating WAIC}{

}

\examples{

\dontrun{
code <- nimbleCode({
    mu ~ dnorm(0, 1)
    x ~ dnorm(mu, 1)
})
Rmodel <- nimbleModel(code)
conf <- configureMCMC(Rmodel)
nIter <- 1E5
Rmcmc <- buildAPT(conf, Temps=1:10, monitorTmax=TRUE, thinPrintTemps=nIter/10)
Cmodel <- compileNimble(Rmodel)
Cmcmc <- compileNimble(Rmcmc, project=Rmodel)
Cmcmc$run(nIter, reset=TRUE, resetTempering=TRUE, adaptTempts=TRUE, printTemps=TRUE, progressBar=FALSE)
Cmcmc$run(nIter, reset=FALSE, resetTempering=FALSE, adaptTempts=FALSE, printTemps=FALSE, progressBar=TRUE)
samples <- tail(as.matrix(Cmcmc$mvSamples), n=nIter)
head(samples)
}
}
\author{
David Pleydell (adapted from code by Daniel Turek).
}
